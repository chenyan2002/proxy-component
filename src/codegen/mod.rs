use crate::util::{FullTypePath, get_resource_from_trait_name, get_return_type, make_path};
use anyhow::Result;
use quote::quote;
use std::collections::{BTreeMap, BTreeSet};
use std::path::PathBuf;
use syn::{
    File, Ident, Item, ItemEnum, ItemStruct, ItemTrait, Signature, TraitItem, parse_quote,
    visit_mut::VisitMut,
};

mod fuzz;
mod record;
mod replay;

#[derive(clap::Parser)]
pub struct GenerateArgs {
    /// The path to the binding file generated by wit-bindgen.
    pub bindings: PathBuf,
    /// Specifies the type of the WIT component.
    pub mode: GenerateMode,
    /// The path to the output file.
    #[arg(short, long, default_value("lib.rs"))]
    pub output_file: PathBuf,
}
#[derive(clap::ValueEnum, clap::Parser, Clone)]
pub enum GenerateMode {
    /// An arbitrary component, we can only generate an empty stub.
    Stubs,
    /// An instrument component which imports and exports the same interface.
    /// The generated code will redirect the export interface to call the corresponding import interface.
    Instrument,
    /// An instrument component which records all import calls.
    Record,
    /// A virtualized component with no imports, with implementation for replay.
    Replay,
    /// A virtualized component with no imports, with implementation for fuzzing.
    Fuzz,
}
impl GenerateMode {
    pub fn is_instrument(&self) -> bool {
        matches!(self, GenerateMode::Instrument | GenerateMode::Record)
    }
}

pub struct State {
    pub mode: GenerateMode,
    pub traits: BTreeMap<Vec<String>, Vec<ItemTrait>>,
    pub types: BTreeMap<Vec<String>, Vec<TypeInfo>>,
    pub funcs: BTreeMap<Vec<String>, BTreeMap<Option<String>, Vec<Signature>>>,
    pub module_paths: BTreeSet<Vec<String>>,
    pub output: Vec<Item>,
}
pub enum TypeInfo {
    Struct(ItemStruct),
    Enum(ItemEnum),
    Resource(ItemStruct),
    Flag(ItemFlag),
}
pub struct ItemFlag {
    pub name: Ident,
    pub flags: Vec<Ident>,
}

impl GenerateArgs {
    pub fn generate(&self) -> Result<()> {
        let file = std::fs::read_to_string(&self.bindings)?;
        let ast = syn::parse_file(&file)?;

        let mut state = State {
            mode: self.mode.clone(),
            traits: BTreeMap::new(),
            types: BTreeMap::new(),
            funcs: BTreeMap::new(),
            module_paths: BTreeSet::new(),
            output: Vec::new(),
        };
        state.generate_preamble();
        state.find_all_items(&ast.items, vec![]);
        state.generate_stubs();
        let trait_generator = crate::traits::TraitGenerator::new(&state);
        let traits = trait_generator.generate();
        drop(trait_generator);
        state.output.extend(traits);
        let file = state.into_output_file();
        let output = prettyplease::unparse(&file);
        std::fs::write(&self.output_file, output)?;
        Ok(())
    }
}
impl State {
    fn generate_stubs(&mut self) {
        for (module_path, traits) in &self.traits {
            for trait_item in traits {
                let impl_item = self.generate_impl_with_methods(trait_item, module_path);
                self.output.push(impl_item);
            }
        }
    }
    fn generate_preamble(&mut self) {
        let file: File = parse_quote! {
          mod bindings;
          use bindings::*;
          struct Stub;
          bindings::export!(Stub with_types_in bindings);
        };
        self.output = file.items;
    }
    fn generate_impl_with_methods(&self, trait_item: &ItemTrait, module_path: &[String]) -> Item {
        let trait_name = &trait_item.ident.to_string();
        let trait_path = make_path(module_path, trait_name);
        let resource = get_resource_from_trait_name(trait_name);
        let stub: syn::Path = match (&self.mode.is_instrument(), &resource) {
            (true, Some(resource)) => {
                let import_path = get_proxy_path(module_path);
                make_path(&import_path, resource)
            }
            (false, Some(_)) => parse_quote! { MockedResource },
            (_, _) => parse_quote! { Stub },
        };
        // Collect all method signatures from the trait
        let mut methods = Vec::new();
        for item in &trait_item.items {
            match item {
                TraitItem::Type(assoc_type) => {
                    let type_name = &assoc_type.ident;
                    let stub: syn::Path = if self.mode.is_instrument() {
                        let import_path = get_proxy_path(module_path);
                        make_path(&import_path, &type_name.to_string())
                    } else {
                        parse_quote! { MockedResource }
                    };
                    let impl_item = parse_quote! {
                        type #type_name = #stub;
                    };
                    methods.push(syn::ImplItem::Type(impl_item));
                }
                TraitItem::Fn(method) => {
                    if method.sig.ident.to_string().starts_with("_resource_") {
                        continue;
                    }
                    let mut sig = method.sig.clone();
                    let mut transformer = FullTypePath { module_path };
                    transformer.visit_signature_mut(&mut sig);
                    let stub_impl = match self.mode {
                        GenerateMode::Stubs => parse_quote! {
                            #[allow(unused_variables)]
                            #sig {
                                unimplemented!()
                            }
                        },
                        GenerateMode::Instrument | GenerateMode::Record => {
                            if module_path.join("::") == "exports::proxy::conversion::conversion" {
                                self.generate_conversion_func(&sig)
                            } else {
                                self.generate_instrument_func(module_path, &sig, &resource)
                            }
                        }
                        GenerateMode::Replay => {
                            if module_path.join("::") == "exports::proxy::conversion::conversion" {
                                self.generate_conversion_func(&sig)
                            } else {
                                self.generate_replay_func(module_path, &sig, &resource)
                            }
                        }
                        GenerateMode::Fuzz => {
                            if module_path.join("::") == "exports::proxy::conversion::conversion" {
                                self.generate_conversion_func(&sig)
                            } else {
                                self.generate_fuzz_func(module_path, &sig, &resource)
                            }
                        }
                    };
                    methods.push(syn::ImplItem::Fn(stub_impl));
                }
                _ => (),
            }
        }
        parse_quote! {
            impl #trait_path for #stub {
                #(#methods)*
            }
        }
    }

    fn generate_conversion_func(&self, sig: &Signature) -> syn::ImplItemFn {
        let func_name = &sig.ident.to_string();
        let body = if func_name.starts_with("get_wrapped_") {
            quote! { x.to_proxy() }
        } else if func_name.starts_with("get_host_") {
            quote! { x.to_proxy() }
        } else if func_name.starts_with("get_mock_") {
            let resource = get_return_type(&sig.output).unwrap();
            let name = func_name
                .rfind("_magic42_")
                .map(|idx| &func_name[idx + 9..])
                .unwrap();
            quote! {
                #resource::new(MockedResource { handle, name: #name.to_string() })
            }
        } else {
            unreachable!()
        };
        parse_quote! {
            #sig {
                #body
            }
        }
    }
    fn into_output_file(self) -> File {
        File {
            items: self.output,
            shebang: None,
            attrs: Vec::new(),
        }
    }
}

pub fn get_proxy_path(src_path: &[String]) -> Vec<String> {
    assert!(src_path.len() >= 3);
    let mut res = src_path.to_vec();
    let mut wrapped_idx = 0;
    if res[0] == "exports" {
        res.remove(0);
    } else {
        res.insert(0, "exports".to_string());
        wrapped_idx = 1;
    }
    match res[wrapped_idx].strip_prefix("wrapped_") {
        Some(name) => res[wrapped_idx] = name.to_string(),
        None => res[wrapped_idx] = "wrapped_".to_string() + &res[wrapped_idx],
    }
    res
}
