use anyhow::Result;
use quote::ToTokens;
use std::path::{Path, PathBuf};
use syn::{
    File, FnArg, Item, ItemFn, ItemMod, ItemTrait, PatType, TraitItem, parse_quote,
    visit_mut::VisitMut,
};

#[derive(clap::Parser)]
pub struct GenerateArgs {
    /// The path to the binding file generated by wit-bindgen.
    pub bindings: PathBuf,
    /// Specifies the type of the WIT component.
    pub mode: GenerateMode,
    /// The path to the output file.
    #[arg(short, long, default_value("lib.rs"))]
    pub output_file: PathBuf,
}
#[derive(clap::ValueEnum, clap::Parser, Clone)]
pub enum GenerateMode {
    /// An arbitrary component, we can only generate an empty stub.
    Stubs,
    /// A instrument component which imports and exports the same interface.
    /// The generated code will redirect the export interface to call the corresponding import interface.
    Instrument,
    /// A virtualized component with no imports. Currently only used for replay.
    Virtualize,
}

struct TraitInfo {
    module_path: Vec<String>,
    trait_item: ItemTrait,
}
impl GenerateArgs {
    pub fn generate(&self) -> Result<()> {
        let file = std::fs::read_to_string(&self.bindings)?;
        let ast = syn::parse_file(&file)?;
        let traits = self.find_all_traits(&ast.items, vec![]);
        let mut output = self.generate_preamble();
        let stubs = self.generate_stubs(&traits);
        output.items.extend(stubs);
        let output = prettyplease::unparse(&output);
        std::fs::write(&self.output_file, output)?;
        Ok(())
    }

    fn generate_preamble(&self) -> File {
        syn::parse_str(
            r#"
    mod bindings;
    use bindings::*;
    struct Stub;
    bindings::export!(Stub with_types_in bindings);
    "#,
        )
        .unwrap()
    }

    fn find_all_traits(&self, items: &[Item], current_path: Vec<String>) -> Vec<TraitInfo> {
        let mut traits = Vec::new();
        for item in items {
            match item {
                Item::Trait(trait_item) => {
                    traits.push(TraitInfo {
                        module_path: current_path.clone(),
                        trait_item: trait_item.clone(),
                    });
                }
                Item::Mod(module) => {
                    if let Some((_, ref mod_items)) = module.content {
                        let mut new_path = current_path.clone();
                        let mod_name = module.ident.to_string();
                        if current_path.is_empty() && mod_name != "exports" {
                            continue;
                        }
                        new_path.push(mod_name);
                        traits.extend(self.find_all_traits(mod_items, new_path));
                    }
                }
                _ => {}
            }
        }
        traits
    }

    fn generate_stubs(&self, traits: &[TraitInfo]) -> Vec<Item> {
        let mut items = Vec::new();
        for trait_info in traits {
            let impl_with_methods = self.generate_impl_with_methods(trait_info);
            items.push(impl_with_methods);
        }
        items
    }

    fn generate_impl_with_methods(&self, trait_info: &TraitInfo) -> Item {
        let trait_name = &trait_info.trait_item.ident;
        let full_path = if trait_info.module_path.is_empty() {
            trait_name.to_string()
        } else {
            format!("{}::{}", trait_info.module_path.join("::"), trait_name)
        };
        let trait_path: syn::Path = syn::parse_str(&full_path).unwrap();

        // Collect all method signatures from the trait
        let mut methods = Vec::new();

        for item in &trait_info.trait_item.items {
            match item {
                TraitItem::Type(assoc_type) => {
                    let type_name = &assoc_type.ident;
                    let impl_item = parse_quote! {
                        type #type_name = Stub;
                    };
                    methods.push(syn::ImplItem::Type(impl_item));
                }
                TraitItem::Fn(method) => {
                    if method.sig.ident.to_string().starts_with("_resource_") {
                        continue;
                    }
                    let module_path = &trait_info.module_path;
                    let mut sig = method.sig.clone();
                    let mut transformer = FullTypePath { module_path };
                    transformer.visit_signature_mut(&mut sig);
                    let stub_impl = match self.mode {
                        GenerateMode::Stubs => parse_quote! {
                            #[allow(unused_variables)]
                            #sig {
                                unimplemented!()
                            }
                        },
                        GenerateMode::Instrument => {
                            self.generate_instrument_func(module_path, &sig)
                        }
                        GenerateMode::Virtualize => todo!(),
                    };
                    methods.push(syn::ImplItem::Fn(stub_impl));
                }
                _ => (),
            }
        }

        // Create the impl block
        parse_quote! {
            impl #trait_path for Stub {
                #(#methods)*
            }
        }
    }

    fn generate_instrument_func(
        &self,
        module_path: &[String],
        sig: &syn::Signature,
    ) -> syn::ImplItemFn {
        parse_quote! {
            #[allow(unused_variables)]
            #sig {
                unimplemented!()
            }
        }
    }

    fn find_function<'a>(&self, items: &'a [Item], path: &[&str]) -> Option<&'a ItemFn> {
        if path.is_empty() {
            return None;
        }
        if path.len() == 1 {
            for item in items {
                if let Item::Fn(func) = item {
                    if func.sig.ident.to_string() == path[0] {
                        return Some(func);
                    }
                }
            }
            return None;
        }
        for item in items {
            if let Item::Mod(module) = item {
                if module.ident == path[0] {
                    if let Some((_, ref items)) = module.content {
                        return self.find_function(items, &path[1..]);
                    } else {
                        return None;
                    }
                }
            }
        }
        None
    }
}
const BUILTIN_TYPES: &[&str] = &[
    "Self", "Result", "Option", "Vec", "Box", "Rc", "Arc", "String", "str", "u8", "u16", "u32",
    "u64", "u128", "usize", "i8", "i16", "i32", "i64", "i128", "isize", "f32", "f64", "bool",
    "char", "_rt",
];
struct FullTypePath<'a> {
    module_path: &'a [String],
}
impl<'a> VisitMut for FullTypePath<'a> {
    fn visit_type_path_mut(&mut self, ty: &mut syn::TypePath) {
        if ty.qself.is_none() && !ty.path.segments.is_empty() && ty.path.leading_colon.is_none() {
            let ident = &ty.path.segments[0].ident.to_string();
            if BUILTIN_TYPES.contains(&ident.as_str()) {
                if ident == "_rt" {
                    assert!(ty.path.segments.len() == 2);
                    ty.path.segments = ty.path.segments.iter().skip(1).cloned().collect();
                }
                syn::visit_mut::visit_type_path_mut(self, ty);
                return;
            }
            let module_idents = self
                .module_path
                .iter()
                .map(|s| syn::parse_str::<syn::Ident>(s).unwrap());
            let original = &ty.path;
            *ty = parse_quote! {
                #(#module_idents)::*::#original
            };
        }
        syn::visit_mut::visit_type_path_mut(self, ty);
    }
}
/*
fn analyze_function_signature(func: &ItemFn) {
    println!("Function: {}", func.sig.ident);
    println!("Signature: {}\n", quote::quote!(#func.sig));

    for (i, arg) in func.sig.inputs.iter().enumerate() {
        match arg {
            FnArg::Receiver(receiver) => {
                if receiver.reference.is_some() {
                    println!("  Arg {}: &self (borrowed)", i);
                } else {
                    println!("  Arg {}: self (owned)", i);
                }
            }
            FnArg::Typed(PatType { pat, ty, .. }) => {
                let param_name = quote::quote!(#pat).to_string();
                let type_str = quote::quote!(#ty).to_string();

                // Check if it's a reference type
                let is_borrowed = type_str.trim().starts_with("&");

                println!("  Arg {}: {} : {} ({})",
                    i,
                    param_name,
                    type_str,
                    if is_borrowed { "borrowed" } else { "owned" }
                );
            }
        }
    }
}
*/
