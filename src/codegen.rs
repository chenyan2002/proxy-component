use anyhow::Result;
use quote::{ToTokens, quote};
use std::collections::BTreeMap;
use std::path::PathBuf;
use syn::{
    File, FnArg, Ident, Item, ItemEnum, ItemStruct, ItemTrait, Signature, TraitItem, Type,
    Visibility, parse_quote, visit_mut::VisitMut,
};

#[derive(clap::Parser)]
pub struct GenerateArgs {
    /// The path to the binding file generated by wit-bindgen.
    pub bindings: PathBuf,
    /// Specifies the type of the WIT component.
    pub mode: GenerateMode,
    /// The path to the output file.
    #[arg(short, long, default_value("lib.rs"))]
    pub output_file: PathBuf,
}
#[derive(clap::ValueEnum, clap::Parser, Clone)]
pub enum GenerateMode {
    /// An arbitrary component, we can only generate an empty stub.
    Stubs,
    /// A instrument component which imports and exports the same interface.
    /// The generated code will redirect the export interface to call the corresponding import interface.
    Instrument,
    /// A virtualized component with no imports. Currently only used for replay.
    Virtualize,
}

struct State<'a> {
    mode: GenerateMode,
    ast: &'a File,
    traits: BTreeMap<Vec<String>, Vec<ItemTrait>>,
    types: BTreeMap<Vec<String>, Vec<TypeInfo>>,
    output: Vec<Item>,
}
enum TypeInfo {
    Struct(ItemStruct),
    Enum(ItemEnum),
    Resource(ItemStruct),
}

impl GenerateArgs {
    pub fn generate(&self) -> Result<()> {
        let file = std::fs::read_to_string(&self.bindings)?;
        let ast = syn::parse_file(&file)?;

        let mut state = State {
            mode: self.mode.clone(),
            ast: &ast,
            traits: BTreeMap::new(),
            types: BTreeMap::new(),
            output: Vec::new(),
        };
        state.generate_preamble();
        state.find_all_items(&ast.items, vec![]);
        state.generate_stubs();
        state.append_trait_defs();
        let file = state.to_output_file();
        let output = prettyplease::unparse(&file);
        std::fs::write(&self.output_file, output)?;
        Ok(())
    }
}
impl<'ast> State<'ast> {
    fn generate_stubs(&mut self) {
        for (module_path, traits) in &self.traits {
            for trait_item in traits {
                let impl_item = self.generate_impl_with_methods(trait_item, module_path);
                self.output.push(impl_item);
            }
        }
        if matches!(self.mode, GenerateMode::Stubs) {
            return;
        }
        for (module_path, items) in &self.types {
            for item_info in items {
                match item_info {
                    TypeInfo::Resource(resource) => {
                        let items = self.resource_traits(resource, module_path);
                        self.output.extend(items);
                    }
                    TypeInfo::Struct(struct_item) => {
                        //self.output.push(Item::Struct(struct_item.clone()));
                    }
                    TypeInfo::Enum(enum_item) => {
                        let items = self.enum_traits(enum_item, module_path);
                        self.output.extend(items);
                    }
                }
            }
        }
    }
    fn generate_impl_with_methods(&self, trait_item: &ItemTrait, module_path: &[String]) -> Item {
        let trait_name = &trait_item.ident.to_string();
        let trait_path = make_path(module_path, trait_name);
        let import_path = self.get_proxy_path(module_path);
        let resource = match trait_name.strip_prefix("Guest") {
            Some("") => None,
            Some(name) => Some(name.to_string()),
            None => unreachable!(),
        };
        let stub: syn::Path = match (&self.mode, &resource) {
            (GenerateMode::Instrument, Some(resource)) => make_path(&import_path, resource),
            (_, _) => parse_quote! { Stub },
        };
        // Collect all method signatures from the trait
        let mut methods = Vec::new();
        for item in &trait_item.items {
            match item {
                TraitItem::Type(assoc_type) => {
                    let type_name = &assoc_type.ident;
                    let stub: syn::Path = match &self.mode {
                        GenerateMode::Instrument => make_path(&import_path, &type_name.to_string()),
                        _ => parse_quote! { Stub },
                    };
                    let impl_item = parse_quote! {
                        type #type_name = #stub;
                    };
                    methods.push(syn::ImplItem::Type(impl_item));
                }
                TraitItem::Fn(method) => {
                    if method.sig.ident.to_string().starts_with("_resource_") {
                        continue;
                    }
                    let mut sig = method.sig.clone();
                    let mut transformer = FullTypePath { module_path };
                    transformer.visit_signature_mut(&mut sig);
                    let stub_impl = match self.mode {
                        GenerateMode::Stubs => parse_quote! {
                            #[allow(unused_variables)]
                            #sig {
                                unimplemented!()
                            }
                        },
                        GenerateMode::Instrument => {
                            self.generate_instrument_func(module_path, &sig, &resource)
                        }
                        GenerateMode::Virtualize => todo!(),
                    };
                    methods.push(syn::ImplItem::Fn(stub_impl));
                }
                _ => (),
            }
        }
        parse_quote! {
            impl #trait_path for #stub {
                #(#methods)*
            }
        }
    }
    fn generate_instrument_func(
        &self,
        module_path: &[String],
        sig: &Signature,
        resource: &Option<String>,
    ) -> syn::ImplItemFn {
        if module_path.join("::") == "exports::proxy::conversion::conversion" {
            return parse_quote! { #[allow(unused_variables)] #sig { todo!() } };
        }
        let func_name = &sig.ident;
        let (is_method, args) = extract_arg_info(sig);
        let mut import_func = self.get_proxy_path(module_path);
        import_func.push(func_name.to_string());
        let import_sig = find_function(&self.ast.items, &import_func).unwrap();
        let (_, import_args) = extract_arg_info(import_sig);
        let call_args = args
            .iter()
            .zip(import_args.iter())
            .map(|(arg, import_arg)| -> syn::Expr {
                let ident = &arg.ident;
                if import_arg.is_borrowed {
                    parse_quote! { &#ident.to_import() }
                } else {
                    parse_quote! { #ident.to_import() }
                }
            });
        let func: syn::Expr = match (resource.is_some(), is_method.is_some()) {
            (true, true) => parse_quote! { self.#func_name },
            (true, false) => parse_quote! { Self::#func_name },
            (false, _) => syn::parse_str(&import_func.join("::")).unwrap(),
        };
        parse_quote! {
            #sig {
                #func(#(#call_args),*).to_export()
            }
        }
    }
    fn resource_traits(&self, resource: &ItemStruct, module_path: &[String]) -> Vec<Item> {
        let mut res = Vec::new();
        let resource_path = make_path(module_path, &resource.ident.to_string());
        if let GenerateMode::Instrument = &self.mode {
            let output_path = self.get_proxy_path(module_path);
            let output_owned = make_path(&output_path, &resource.ident.to_string());
            let in_import = module_path[0] != "exports";
            if in_import {
                let export_borrow =
                    make_path(&output_path, &format!("{}Borrow<'a>", &resource.ident));
                res.push(parse_quote! {
                impl ToExport for #resource_path {
                  type Output = #output_owned;
                  fn to_export(self) -> Self::Output {
                    Self::Output::new(self)
                  }
                }});
                res.push(parse_quote! {
                impl<'a> ToExport for &'a #resource_path {
                  type Output = #export_borrow;
                  fn to_export(self) -> Self::Output {
                    unsafe { Self::Output::lift(self as *const _ as usize) }
                  }
                }});
            } else {
                let export_borrow =
                    make_path(module_path, &format!("{}Borrow<'a>", &resource.ident));
                res.push(parse_quote! {
                    impl ToImport for #resource_path {
                        type Output = #output_owned;
                        fn to_import(self) -> Self::Output {
                            self.into_inner()
                        }
                    }
                });
                res.push(parse_quote! {
                    impl<'a> ToImport for #export_borrow {
                        type Output = &'a #output_owned;
                        fn to_import(self) -> Self::Output {
                            todo!()
                            //type T = #output_owned;
                            //let ptr = unsafe { &mut *self.as_ptr::<T>() };
                            //ptr.as_ref().unwrap()*/
                        }
                    }
                });
            }
        }
        res
    }
    fn enum_traits(&self, enum_item: &ItemEnum, module_path: &[String]) -> Vec<Item> {
        let mut res = Vec::new();
        let enum_name = make_path(module_path, &enum_item.ident.to_string());
        let (impl_generics, ty_generics, where_clause) = enum_item.generics.split_for_impl();
        if let GenerateMode::Instrument = &self.mode {
            let is_import = module_path[0] != "exports";
            let output_path = self.get_proxy_path(module_path);
            let output_path = make_path(&output_path, &enum_item.ident.to_string());
            let (trait_name, func) = if is_import {
                (quote! {ToExport}, quote! {to_export})
            } else {
                (quote! {ToImport}, quote! {to_import})
            };
            let match_arms = enum_item.variants.iter().map(|variant| {
                let tag = &variant.ident;
                match &variant.fields {
                    syn::Fields::Unit => quote! { Self::#tag => Self::Output::#tag },
                    syn::Fields::Unnamed(_) => {
                        quote! { Self::#tag(e) => Self::Output::#tag(e.#func()) }
                    }
                    syn::Fields::Named(_) => unreachable!(),
                }
            });
            res.push(parse_quote! {
                impl #impl_generics #trait_name for #enum_name #ty_generics #where_clause {
                    type Output = #output_path;
                    fn #func(self) -> Self::Output {
                        match self {
                            #(#match_arms),*
                        }
                    }
                }
            });
        }
        res
    }
    fn get_proxy_path(&self, src_path: &[String]) -> Vec<String> {
        assert!(matches!(self.mode, GenerateMode::Instrument));
        assert!(src_path.len() >= 3);
        let mut res = src_path.to_vec();
        let mut wrapped_idx = 0;
        if res[0] == "exports" {
            res.remove(0);
        } else {
            res.insert(0, "exports".to_string());
            wrapped_idx = 1;
        }
        match res[wrapped_idx].strip_prefix("wrapped_") {
            Some(name) => res[wrapped_idx] = name.to_string(),
            None => res[wrapped_idx] = "wrapped_".to_string() + &res[wrapped_idx],
        }
        res
    }
    fn find_all_items(&mut self, items: &[Item], current_path: Vec<String>) {
        for item in items {
            match item {
                Item::Trait(trait_item) if matches!(trait_item.vis, Visibility::Public(_)) => {
                    self.traits
                        .entry(current_path.clone())
                        .or_insert_with(Vec::new)
                        .push(trait_item.clone());
                }
                Item::Struct(struct_item) if matches!(struct_item.vis, Visibility::Public(_)) => {
                    let has_repr_transparent = struct_item.attrs.iter().any(|attr| {
                        attr.path().is_ident("repr")
                            && attr.to_token_stream().to_string().contains("transparent")
                    });
                    let type_info = if has_repr_transparent {
                        if struct_item.ident.to_string().ends_with("Borrow")
                            && current_path[0] == "exports"
                        {
                            continue;
                        }
                        TypeInfo::Resource(struct_item.clone())
                    } else {
                        TypeInfo::Struct(struct_item.clone())
                    };
                    self.types
                        .entry(current_path.clone())
                        .or_insert_with(Vec::new)
                        .push(type_info);
                }
                Item::Enum(enum_item) if matches!(enum_item.vis, Visibility::Public(_)) => {
                    self.types
                        .entry(current_path.clone())
                        .or_insert_with(Vec::new)
                        .push(TypeInfo::Enum(enum_item.clone()));
                }
                Item::Mod(module) if matches!(module.vis, Visibility::Public(_)) => {
                    if let Some((_, ref mod_items)) = module.content {
                        let mut new_path = current_path.clone();
                        let mod_name = module.ident.to_string();
                        if current_path.is_empty() && mod_name == "_rt" {
                            continue;
                        }
                        new_path.push(mod_name);
                        self.find_all_items(mod_items, new_path);
                    }
                }
                _ => {}
            }
        }
    }
    fn generate_preamble(&mut self) {
        let file: File = parse_quote! {
          mod bindings;
          use bindings::*;
          struct Stub;
        };
        self.output = file.items;
    }
    fn append_trait_defs(&mut self) {
        if let GenerateMode::Instrument = &self.mode {
            let instrument: File = parse_quote! {
            trait ToExport {
              type Output;
              fn to_export(self) -> Self::Output;
            }
            trait ToImport {
              type Output;
              fn to_import(self) -> Self::Output;
            }
            impl crate::ToExport for String {
                type Output = String;
                fn to_export(self) -> Self::Output {
                    self
                }
            }
            impl crate::ToImport for String {
              type Output = String;
              fn to_import(self) -> Self::Output {
                self
              }
            }
            impl<T: crate::ToExport> crate::ToExport for Vec::<T> {
                type Output = Vec::<T::Output>;
                fn to_export(self) -> Self::Output {
                    self.into_iter().map(|x| x.to_export()).collect()
                }
            }
            impl<T: crate::ToImport> crate::ToImport for Vec::<T> {
                type Output = Vec::<T::Output>;
                fn to_import(self) -> Self::Output {
                    self.into_iter().map(|x| x.to_import()).collect()
                }
            }
            impl<Ok, Err> ToExport for Result<Ok, Err>
            where Ok: ToExport, Err: ToExport {
                type Output = Result<Ok::Output, Err::Output>;
                fn to_export(self) -> Self::Output {
                    match self {
                        Ok(ok) => Ok(ok.to_export()),
                        Err(err) => Err(err.to_export()),
                    }
                }
            }
            impl<Ok, Err> ToImport for Result<Ok, Err>
            where Ok: ToImport, Err: ToImport {
                type Output = Result<Ok::Output, Err::Output>;
                fn to_import(self) -> Self::Output {
                    match self {
                        Ok(ok) => Ok(ok.to_import()),
                        Err(err) => Err(err.to_import()),
                    }
                }
            }
            impl<Inner> ToExport for Option<Inner>
            where Inner: ToExport {
                type Output = Option<Inner::Output>;
                fn to_export(self) -> Self::Output {
                    self.map(|x| x.to_export())
                }
            }
            impl<Inner> ToImport for Option<Inner>
            where Inner: ToImport {
                type Output = Option<Inner::Output>;
                fn to_import(self) -> Self::Output {
                    self.map(|x| x.to_import())
                }
            }
            macro_rules! impl_to_import_export_for_primitive {
                ($($t:ty),*) => {
                    $(
                        impl ToImport for $t {
                            type Output = $t;
                            fn to_import(self) -> Self::Output {
                                self
                            }
                        }
                        impl ToExport for $t {
                            type Output = $t;
                            fn to_export(self) -> Self::Output {
                                self
                            }
                        }
                    )*
                };
            }
            impl_to_import_export_for_primitive!(u8, u16, u32, u64, i8, i16, i32, i64, usize, isize, f32, f64, (), bool, char);

            macro_rules! impl_to_import_export_for_tuple {
                ( $($T:ident, $i:tt),* ) => {
                    impl<$($T: ToExport),*> ToExport for ($($T,)*) {
                        type Output = ($($T::Output,)*);
                        fn to_export(self) -> Self::Output {
                            ($(self.$i.to_export(),)*)
                        }
                    }
                };
            }
            impl_to_import_export_for_tuple!(T0, 0);
            impl_to_import_export_for_tuple!(T0, 0, T1, 1);
            impl_to_import_export_for_tuple!(T0, 0, T1, 1, T2, 2);
            impl_to_import_export_for_tuple!(T0, 0, T1, 1, T2, 2, T3, 3);
            impl_to_import_export_for_tuple!(T0, 0, T1, 1, T2, 2, T3, 3, T4, 4);
            impl_to_import_export_for_tuple!(T0, 0, T1, 1, T2, 2, T3, 3, T4, 4, T5, 5);
            impl_to_import_export_for_tuple!(T0, 0, T1, 1, T2, 2, T3, 3, T4, 4, T5, 5, T6, 6);
            };
            self.output.extend(instrument.items);
        }
        let end: Item = parse_quote! { bindings::export!(Stub with_types_in bindings); };
        self.output.push(end);
    }
    fn to_output_file(self) -> File {
        File {
            items: self.output,
            shebang: None,
            attrs: Vec::new(),
        }
    }
}

fn find_function<'a>(items: &'a [Item], path: &[String]) -> Option<&'a Signature> {
    if path.is_empty() {
        return None;
    }
    if path.len() == 1 {
        for item in items {
            match item {
                Item::Fn(func) => {
                    if func.sig.ident == path[0] {
                        return Some(&func.sig);
                    }
                }
                Item::Impl(impl_block) => {
                    for impl_item in &impl_block.items {
                        if let syn::ImplItem::Fn(method) = impl_item
                            && method.sig.ident == path[0]
                        {
                            return Some(&method.sig);
                        }
                    }
                }
                Item::Trait(trait_block) => {
                    for trait_item in &trait_block.items {
                        if let syn::TraitItem::Fn(method) = trait_item
                            && method.sig.ident == path[0]
                        {
                            return Some(&method.sig);
                        }
                    }
                }
                _ => {}
            }
        }
        return None;
    }
    for item in items {
        if let Item::Mod(module) = item
            && module.ident == path[0]
        {
            if let Some((_, ref items)) = module.content {
                return find_function(items, &path[1..]);
            } else {
                return None;
            }
        }
    }
    None
}

const BUILTIN_TYPES: &[&str] = &[
    "Self", "Result", "Option", "Vec", "Box", "Rc", "Arc", "String", "str", "u8", "u16", "u32",
    "u64", "u128", "usize", "i8", "i16", "i32", "i64", "i128", "isize", "f32", "f64", "bool",
    "char", "_rt",
];
struct FullTypePath<'a> {
    module_path: &'a [String],
}
impl<'a> VisitMut for FullTypePath<'a> {
    fn visit_type_path_mut(&mut self, ty: &mut syn::TypePath) {
        if ty.qself.is_none() && !ty.path.segments.is_empty() && ty.path.leading_colon.is_none() {
            let ident = &ty.path.segments[0].ident.to_string();
            if BUILTIN_TYPES.contains(&ident.as_str()) {
                if ident == "_rt" {
                    assert!(ty.path.segments.len() == 2);
                    ty.path.segments = ty.path.segments.iter().skip(1).cloned().collect();
                }
                syn::visit_mut::visit_type_path_mut(self, ty);
                return;
            }
            let module_idents = self
                .module_path
                .iter()
                .map(|s| syn::parse_str::<syn::Ident>(s).unwrap());
            let original = &ty.path;
            *ty = parse_quote! {
                #(#module_idents)::*::#original
            };
        }
        syn::visit_mut::visit_type_path_mut(self, ty);
    }
}

struct ArgInfo {
    ident: Ident,
    is_borrowed: bool,
}
fn extract_arg_info(sig: &Signature) -> (Option<bool>, Vec<ArgInfo>) {
    let mut is_method = None;
    let mut arg_infos = Vec::new();
    for arg in sig.inputs.iter() {
        match arg {
            FnArg::Receiver(receiver) => {
                let is_borrowed = receiver.reference.is_some();
                is_method = Some(is_borrowed);
            }
            FnArg::Typed(pat_type) => {
                let ident = match &*pat_type.pat {
                    syn::Pat::Ident(ident) => ident.ident.clone(),
                    _ => unreachable!(),
                };
                let is_borrowed = matches!(&*pat_type.ty, Type::Reference(_));
                arg_infos.push(ArgInfo { ident, is_borrowed });
            }
        }
    }
    (is_method, arg_infos)
}
fn make_path(module_path: &[String], name: &str) -> syn::Path {
    let path = format!("{}::{}", module_path.join("::"), name);
    syn::parse_str(&path).unwrap()
}
