use anyhow::Result;
use heck::ToKebabCase;
use quote::{ToTokens, quote};
use std::collections::{BTreeMap, BTreeSet};
use std::path::PathBuf;
use syn::{
    File, FnArg, Ident, Item, ItemEnum, ItemStruct, ItemTrait, Signature, TraitItem, Type,
    Visibility, parse_quote, visit_mut::VisitMut,
};

#[derive(clap::Parser)]
pub struct GenerateArgs {
    /// The path to the binding file generated by wit-bindgen.
    pub bindings: PathBuf,
    /// Specifies the type of the WIT component.
    pub mode: GenerateMode,
    /// The path to the output file.
    #[arg(short, long, default_value("lib.rs"))]
    pub output_file: PathBuf,
}
#[derive(clap::ValueEnum, clap::Parser, Clone)]
pub enum GenerateMode {
    /// An arbitrary component, we can only generate an empty stub.
    Stubs,
    /// An instrument component which imports and exports the same interface.
    /// The generated code will redirect the export interface to call the corresponding import interface.
    Instrument,
    /// An instrument component which records all import calls.
    Record,
    /// A virtualized component with no imports. Currently only used for replay.
    Replay,
}
impl GenerateMode {
    pub fn is_instrument(&self) -> bool {
        matches!(self, GenerateMode::Instrument | GenerateMode::Record)
    }
}

pub struct State<'a> {
    pub mode: GenerateMode,
    pub ast: &'a File,
    pub traits: BTreeMap<Vec<String>, Vec<ItemTrait>>,
    pub types: BTreeMap<Vec<String>, Vec<TypeInfo>>,
    pub funcs: BTreeMap<Vec<String>, BTreeMap<Option<String>, Vec<Signature>>>,
    pub module_paths: BTreeSet<Vec<String>>,
    pub output: Vec<Item>,
}
pub enum TypeInfo {
    Struct(ItemStruct),
    Enum(ItemEnum),
    Resource(ItemStruct),
}

impl GenerateArgs {
    pub fn generate(&self) -> Result<()> {
        let file = std::fs::read_to_string(&self.bindings)?;
        let ast = syn::parse_file(&file)?;

        let mut state = State {
            mode: self.mode.clone(),
            ast: &ast,
            traits: BTreeMap::new(),
            types: BTreeMap::new(),
            funcs: BTreeMap::new(),
            module_paths: BTreeSet::new(),
            output: Vec::new(),
        };
        state.generate_preamble();
        state.find_all_items(&ast.items, vec![]);
        state.generate_stubs();
        let trait_generator = crate::traits::TraitGenerator::new(&state);
        let traits = trait_generator.generate();
        drop(trait_generator);
        state.output.extend(traits);
        let file = state.into_output_file();
        let output = prettyplease::unparse(&file);
        std::fs::write(&self.output_file, output)?;
        Ok(())
    }
}
impl<'ast> State<'ast> {
    fn generate_stubs(&mut self) {
        for (module_path, traits) in &self.traits {
            for trait_item in traits {
                let impl_item = self.generate_impl_with_methods(trait_item, module_path);
                self.output.push(impl_item);
            }
        }
    }
    fn generate_impl_with_methods(&self, trait_item: &ItemTrait, module_path: &[String]) -> Item {
        let trait_name = &trait_item.ident.to_string();
        let trait_path = make_path(module_path, trait_name);
        let resource = get_resource_from_trait_name(trait_name);
        let stub: syn::Path = match (&self.mode.is_instrument(), &resource) {
            (true, Some(resource)) => {
                let import_path = get_proxy_path(module_path);
                make_path(&import_path, resource)
            }
            (_, _) => parse_quote! { Stub },
        };
        // Collect all method signatures from the trait
        let mut methods = Vec::new();
        for item in &trait_item.items {
            match item {
                TraitItem::Type(assoc_type) => {
                    let type_name = &assoc_type.ident;
                    let stub: syn::Path = if self.mode.is_instrument() {
                        let import_path = get_proxy_path(module_path);
                        make_path(&import_path, &type_name.to_string())
                    } else {
                        parse_quote! { Stub }
                    };
                    let impl_item = parse_quote! {
                        type #type_name = #stub;
                    };
                    methods.push(syn::ImplItem::Type(impl_item));
                }
                TraitItem::Fn(method) => {
                    if method.sig.ident.to_string().starts_with("_resource_") {
                        continue;
                    }
                    let mut sig = method.sig.clone();
                    let mut transformer = FullTypePath { module_path };
                    transformer.visit_signature_mut(&mut sig);
                    let stub_impl = match self.mode {
                        GenerateMode::Stubs => parse_quote! {
                            #[allow(unused_variables)]
                            #sig {
                                unimplemented!()
                            }
                        },
                        GenerateMode::Instrument | GenerateMode::Record => {
                            if module_path.join("::") == "exports::proxy::conversion::conversion" {
                                self.generate_conversion_func(&sig)
                            } else {
                                self.generate_instrument_func(module_path, &sig, &resource)
                            }
                        }
                        GenerateMode::Replay => {
                            if module_path.join("::") == "exports::proxy::conversion::conversion" {
                                self.generate_conversion_func(&sig)
                            } else {
                                self.generate_replay_func(module_path, &sig, &resource)
                            }
                        }
                    };
                    methods.push(syn::ImplItem::Fn(stub_impl));
                }
                _ => (),
            }
        }
        parse_quote! {
            impl #trait_path for #stub {
                #(#methods)*
            }
        }
    }
    fn generate_replay_func(
        &self,
        module_path: &[String],
        sig: &Signature,
        resource: &Option<String>,
    ) -> syn::ImplItemFn {
        let func_name = &sig.ident;
        let is_export = module_path.join("::") == "exports::proxy::recorder::start_replay";
        if !is_export {
            let (is_method, args) = extract_arg_info(sig);
            let arg_names = args.iter().map(|arg| &arg.ident);
            let display_name = wit_func_name(module_path, resource, func_name, is_method);
            let ret_ty = get_return_type(&sig.output);
            let replay_import = if let Some(ret_ty) = ret_ty {
                quote! {
                    let wave = proxy::recorder::replay::replay_import(Some(#display_name), Some(&args)).unwrap();
                    let ret: Value = wasm_wave::from_str(&<#ret_ty as ValueTyped>::value_type(), &wave).unwrap();
                    ret.to_rust()
                }
            } else {
                quote! {
                    let wave = proxy::recorder::replay::replay_import(Some(#display_name), Some(&args));
                    assert!(wave.is_none());
                }
            };
            parse_quote! {
                #sig {
                    let args = vec![#( wasm_wave::to_string(&#arg_names.to_value()).unwrap() ),*];
                    #replay_import
                }
            }
        } else {
            assert!(func_name == "start");
            let arms = self
                .funcs
                .iter()
                .filter(|(path, _)| path[0] != "exports" && path[0] != "proxy")
                .flat_map(|(path, resources)| {
                    resources.iter().flat_map(move |(resource, sigs)| {
                        sigs.iter().filter_map(move |sig| {
                            let (is_method, args) = extract_arg_info(sig);
                            if is_method.is_some() {
                                return None;
                            }
                            let arg_name: Vec<_> = args.iter().map(|arg| &arg.ident).collect();
                            let arg_idx = args.iter().enumerate().map(|(idx, _)| quote! { args[#idx] });
                            let call_param = args.iter().map(|arg| arg.call_param());
                            let ty = args.iter().map(|arg| {
                                let mut ty = arg.ty.clone();
                                FullTypePath {
                                    module_path: path,
                                }.visit_type_mut(&mut ty);
                                if let Some(owned) = get_owned_type(&ty) {
                                    owned
                                } else {
                                    ty
                                }
                            });
                            let func_name = if let Some(resource) = resource {
                                format!("{}::{}", resource, sig.ident)
                            } else {
                                sig.ident.to_string()
                            };
                            let func = make_path(path, &func_name);
                            let display_name = wit_func_name(path, resource, &sig.ident, None);
                            let assert_ret = if get_return_type(&sig.output).is_none() {
                                quote! {
                                    assert!(res == ());
                                    proxy::recorder::replay::assert_export_ret(Some(#display_name), None);
                                }
                            } else {
                                quote! {
                                    let wave_res = wasm_wave::to_string(&res.to_value()).unwrap();
                                    proxy::recorder::replay::assert_export_ret(Some(#display_name), Some(&wave_res));
                                }
                            };
                            Some(quote! {
                                #display_name => {
                                    #(
                                        let arg_value: Value = wasm_wave::from_str(&<#ty as ValueTyped>::value_type(), &#arg_idx).unwrap();
                                        let #arg_name: #ty = arg_value.to_rust();
                                    )*
                                    let res = #func(#(#call_param),*);
                                    #assert_ret
                                }
                            })
                        })
                    })
                });
            parse_quote! {
                #sig {
                    while let Some((method, args)) = proxy::recorder::replay::replay_export() {
                        match method.as_str() {
                            #(#arms)*
                            _ => unreachable!(),
                        }
                    }
                }
            }
        }
    }
    fn generate_instrument_func(
        &self,
        module_path: &[String],
        sig: &Signature,
        resource: &Option<String>,
    ) -> syn::ImplItemFn {
        let func_name = &sig.ident;
        let (is_method, args) = extract_arg_info(sig);
        let import_path = get_proxy_path(module_path);
        let import_sig = self
            .find_function(&import_path, resource, &func_name)
            .unwrap();
        let (_, import_args) = extract_arg_info(import_sig);
        let arg_names = args.iter().map(|arg| &arg.ident);
        let call_args = args
            .iter()
            .zip(import_args.iter())
            .map(|(arg, import_arg)| -> syn::Expr {
                let ident = &arg.ident;
                if import_arg.is_borrowed {
                    parse_quote! { &#ident }
                } else {
                    parse_quote! { #ident }
                }
            });
        let func: syn::Expr = match (resource.is_some(), is_method.is_some()) {
            (true, true) => parse_quote! { self.#func_name },
            (true, false) => parse_quote! { Self::#func_name },
            (false, _) => {
                syn::parse_str(&format!("{}::{}", import_path.join("::"), func_name)).unwrap()
            }
        };
        match &self.mode {
            GenerateMode::Instrument => parse_quote! {
                #sig {
                    #func(#(#call_args.to_proxy()),*).to_proxy()
                }
            },
            GenerateMode::Record => {
                let init_vec = if is_method.is_some() {
                    quote! { vec![wasm_wave::to_string(&ToValue::to_value(&self)).unwrap()] }
                } else {
                    quote! { Vec::new() }
                };
                let is_mut = if args.is_empty() {
                    quote! {}
                } else {
                    quote! { mut }
                };
                let display_name = wit_func_name(module_path, resource, func_name, is_method);
                let is_export = !module_path[1].starts_with("wrapped_");
                let record_ret = if get_return_type(&sig.output).is_none() {
                    quote! {
                        #func(#(#call_args),*);
                        proxy::recorder::record::record_ret(Some(#display_name), None, #is_export);
                    }
                } else {
                    quote! {
                       let res = #func(#(#call_args),*);
                       let wave_res = wasm_wave::to_string(&res.to_value()).unwrap();
                       proxy::recorder::record::record_ret(Some(#display_name), Some(&wave_res), #is_export);
                       res.to_proxy()
                    }
                };
                parse_quote! {
                    #sig {
                        let #is_mut params: Vec<String> = #init_vec;
                        #(
                            let #arg_names = #arg_names.to_proxy();
                            params.push(wasm_wave::to_string(&ToValue::to_value(&#arg_names)).unwrap());
                        )*
                        proxy::recorder::record::record_args(Some(#display_name), &params, #is_export);
                        #record_ret
                    }
                }
            }
            _ => unreachable!(),
        }
    }
    fn generate_conversion_func(&self, sig: &Signature) -> syn::ImplItemFn {
        let func_name = &sig.ident.to_string();
        let body = if func_name.starts_with("get_wrapped_") {
            quote! { x.to_proxy() }
        } else if func_name.starts_with("get_host_") {
            quote! { x.to_proxy() }
        } else if func_name.starts_with("get_mock_") {
            let resource = get_return_type(&sig.output).unwrap();
            quote! {
                let res = #resource::new(Stub);
                let ptr = res.as_ptr::<Stub>() as u32;
                TABLE.with(|map| {
                    map.borrow_mut().insert(ptr, handle);
                });
                res
            }
        } else {
            unreachable!()
        };
        parse_quote! {
            #sig {
                #body
            }
        }
    }
    fn find_all_items(&mut self, items: &[Item], current_path: Vec<String>) {
        for item in items {
            match item {
                Item::Trait(trait_item) if matches!(trait_item.vis, Visibility::Public(_)) => {
                    let trait_item = trait_item.clone();
                    let resource = get_resource_from_trait_name(&trait_item.ident.to_string());
                    let funcs = self
                        .funcs
                        .entry(current_path.clone())
                        .or_default()
                        .entry(resource)
                        .or_default();
                    for item in &trait_item.items {
                        if let syn::TraitItem::Fn(method) = item {
                            funcs.push(method.sig.clone());
                        }
                    }
                    self.traits
                        .entry(current_path.clone())
                        .or_default()
                        .push(trait_item);
                }
                Item::Impl(impl_item) if impl_item.trait_.is_none() => {
                    let resource = if let Type::Path(type_path) = &*impl_item.self_ty {
                        type_path.path.segments.last().unwrap().ident.to_string()
                    } else {
                        unreachable!()
                    };
                    let funcs = self
                        .funcs
                        .entry(current_path.clone())
                        .or_default()
                        .entry(Some(resource))
                        .or_default();
                    for item in &impl_item.items {
                        if let syn::ImplItem::Fn(method) = item {
                            if !matches!(method.vis, Visibility::Public(_)) {
                                continue;
                            }
                            if has_doc_hidden(&method.attrs) {
                                continue;
                            }
                            funcs.push(method.sig.clone());
                        }
                    }
                }
                Item::Fn(func_item)
                    if matches!(func_item.vis, Visibility::Public(_))
                        && current_path.len() >= 3 =>
                {
                    self.funcs
                        .entry(current_path.clone())
                        .or_default()
                        .entry(None)
                        .or_default()
                        .push(func_item.sig.clone());
                }
                Item::Struct(struct_item) if matches!(struct_item.vis, Visibility::Public(_)) => {
                    let has_repr_transparent = struct_item.attrs.iter().any(|attr| {
                        attr.path().is_ident("repr")
                            && attr.to_token_stream().to_string().contains("transparent")
                    });
                    let type_info = if has_repr_transparent {
                        if struct_item.ident.to_string().ends_with("Borrow")
                            && current_path[0] == "exports"
                        {
                            continue;
                        }
                        TypeInfo::Resource(struct_item.clone())
                    } else {
                        let mut struct_item = struct_item.clone();
                        let mut transformer = FullTypePath {
                            module_path: &current_path,
                        };
                        transformer.visit_item_struct_mut(&mut struct_item);
                        TypeInfo::Struct(struct_item)
                    };
                    self.types
                        .entry(current_path.clone())
                        .or_default()
                        .push(type_info);
                }
                Item::Enum(enum_item) if matches!(enum_item.vis, Visibility::Public(_)) => {
                    let mut enum_item = enum_item.clone();
                    let mut transformer = FullTypePath {
                        module_path: &current_path,
                    };
                    transformer.visit_item_enum_mut(&mut enum_item);
                    self.types
                        .entry(current_path.clone())
                        .or_default()
                        .push(TypeInfo::Enum(enum_item));
                }
                Item::Mod(module) if matches!(module.vis, Visibility::Public(_)) => {
                    if let Some((_, ref mod_items)) = module.content {
                        let mut new_path = current_path.clone();
                        let mod_name = module.ident.to_string();
                        if current_path.is_empty() && mod_name == "_rt" {
                            continue;
                        }
                        new_path.push(mod_name);
                        self.module_paths.insert(new_path.clone());
                        self.find_all_items(mod_items, new_path);
                    }
                }
                _ => {}
            }
        }
    }
    fn generate_preamble(&mut self) {
        let file: File = parse_quote! {
          mod bindings;
          use bindings::*;
          struct Stub;
          bindings::export!(Stub with_types_in bindings);
        };
        self.output = file.items;
        match &self.mode {
            GenerateMode::Record => {
                self.output.push(parse_quote! {
                    #[allow(unused_imports)]
                    use wasm_wave::{wasm::WasmValue, value::{Value, Type, convert::{ToValue, ValueTyped}}};
                });
            }
            GenerateMode::Replay => {
                let code: File = parse_quote! {
                    #[allow(unused_imports)]
                    use wasm_wave::{wasm::WasmValue, value::{Value, Type, convert::{ToRust, ToValue, ValueTyped}}};
                    use std::collections::BTreeMap;
                    use std::cell::RefCell;
                    thread_local! {
                        static TABLE: RefCell<BTreeMap<u32, u32>> = RefCell::new(BTreeMap::new());
                    }
                };
                self.output.extend(code.items);
            }
            _ => (),
        }
    }
    fn into_output_file(self) -> File {
        File {
            items: self.output,
            shebang: None,
            attrs: Vec::new(),
        }
    }
    fn find_function(
        &self,
        module_path: &[String],
        resource: &Option<String>,
        func: &Ident,
    ) -> Option<&Signature> {
        let module = self.funcs.get(module_path)?;
        let funcs = module.get(resource)?;
        funcs.iter().find(|sig| sig.ident == *func)
    }
}

const BUILTIN_TYPES: &[&str] = &[
    "Self", "Result", "Option", "Vec", "Box", "Rc", "Arc", "String", "str", "u8", "u16", "u32",
    "u64", "u128", "usize", "i8", "i16", "i32", "i64", "i128", "isize", "f32", "f64", "bool",
    "char", "_rt",
];
struct FullTypePath<'a> {
    module_path: &'a [String],
}
impl<'a> VisitMut for FullTypePath<'a> {
    fn visit_type_path_mut(&mut self, ty: &mut syn::TypePath) {
        if ty.qself.is_none() && !ty.path.segments.is_empty() && ty.path.leading_colon.is_none() {
            let ident = &ty.path.segments[0].ident.to_string();
            if BUILTIN_TYPES.contains(&ident.as_str()) {
                if ident == "_rt" {
                    assert!(ty.path.segments.len() == 2);
                    ty.path.segments = ty.path.segments.iter().skip(1).cloned().collect();
                }
                syn::visit_mut::visit_type_path_mut(self, ty);
                return;
            }
            let module_idents = self
                .module_path
                .iter()
                .map(|s| syn::parse_str::<syn::Ident>(s).unwrap());
            let original = &ty.path;
            *ty = parse_quote! {
                #(#module_idents)::*::#original
            };
        }
        syn::visit_mut::visit_type_path_mut(self, ty);
    }
}

struct ArgInfo {
    ident: Ident,
    is_borrowed: bool,
    ty: Type,
}
fn extract_arg_info(sig: &Signature) -> (Option<bool>, Vec<ArgInfo>) {
    let mut is_method = None;
    let mut arg_infos = Vec::new();
    for arg in sig.inputs.iter() {
        match arg {
            FnArg::Receiver(receiver) => {
                let is_borrowed = receiver.reference.is_some();
                is_method = Some(is_borrowed);
            }
            FnArg::Typed(pat_type) => {
                let ident = match &*pat_type.pat {
                    syn::Pat::Ident(ident) => ident.ident.clone(),
                    _ => unreachable!(),
                };
                let ty = *pat_type.ty.clone();
                let is_borrowed = matches!(&*pat_type.ty, Type::Reference(_));
                arg_infos.push(ArgInfo {
                    ident,
                    is_borrowed,
                    ty,
                });
            }
        }
    }
    (is_method, arg_infos)
}
pub fn get_proxy_path(src_path: &[String]) -> Vec<String> {
    assert!(src_path.len() >= 3);
    let mut res = src_path.to_vec();
    let mut wrapped_idx = 0;
    if res[0] == "exports" {
        res.remove(0);
    } else {
        res.insert(0, "exports".to_string());
        wrapped_idx = 1;
    }
    match res[wrapped_idx].strip_prefix("wrapped_") {
        Some(name) => res[wrapped_idx] = name.to_string(),
        None => res[wrapped_idx] = "wrapped_".to_string() + &res[wrapped_idx],
    }
    res
}
pub fn make_path(module_path: &[String], name: &str) -> syn::Path {
    let path = format!("{}::{}", module_path.join("::"), name);
    syn::parse_str(&path).unwrap()
}
fn wit_func_name(
    module_path: &[String],
    resource: &Option<String>,
    func_name: &Ident,
    is_method: Option<bool>,
) -> String {
    assert!(module_path.len() >= 3);
    let mut module_path = module_path.to_vec();
    if module_path[0] == "exports" {
        module_path.remove(0);
    }
    assert!(module_path.len() == 3);
    let mut res = String::new();
    if is_method.is_some() {
        res.push_str("[method]");
    }
    let nonwrapped = module_path[0]
        .strip_prefix("wrapped_")
        .unwrap_or(&module_path[0]);
    res.push_str(&nonwrapped.to_kebab_case());
    res.push(':');
    res.push_str(&module_path[1].to_kebab_case());
    res.push('/');
    res.push_str(&module_path[2].to_kebab_case());
    if let Some(name) = resource {
        res.push_str(&format!("/{}", name.to_kebab_case()));
    }
    res.push('.');
    res.push_str(&func_name.to_string().to_kebab_case());
    res
}
fn get_return_type(ret: &syn::ReturnType) -> Option<Type> {
    match ret {
        syn::ReturnType::Default => None,
        syn::ReturnType::Type(_, ty) => match **ty {
            Type::Tuple(ref tuple) if tuple.elems.is_empty() => None,
            _ => Some(*ty.clone()),
        },
    }
}
fn get_resource_from_trait_name(trait_name: &str) -> Option<String> {
    let resource = trait_name.strip_prefix("Guest").unwrap();
    match resource {
        "" => None,
        name => Some(name.to_string()),
    }
}
impl ArgInfo {
    fn call_param(&self) -> syn::Expr {
        let ident = &self.ident;
        if self.is_borrowed {
            parse_quote! { &#ident }
        } else {
            parse_quote! { #ident }
        }
    }
}
fn get_owned_type(ty: &Type) -> Option<Type> {
    match ty {
        Type::Reference(type_ref) => {
            match &*type_ref.elem {
                Type::Slice(type_slice) => {
                    let inner_ty = &*type_slice.elem;
                    Some(parse_quote! { Vec<#inner_ty> })
                }
                Type::Path(type_path) => {
                    if type_path.qself.is_none()
                        && type_path.path.segments.len() == 1
                        && type_path.path.segments[0].ident == "str"
                    {
                        Some(parse_quote! { String })
                    } else {
                        // TODO: need to handle nested borrow
                        Some(parse_quote! { #type_path })
                    }
                }
                _ => None,
            }
        }
        _ => None,
    }
}

fn has_doc_hidden(attrs: &[syn::Attribute]) -> bool {
    for attr in attrs {
        if attr.path().is_ident("doc") {
            if let syn::Meta::List(meta_list) = &attr.meta {
                if meta_list.to_token_stream().to_string().contains("hidden") {
                    return true;
                }
            }
        }
    }
    false
}
